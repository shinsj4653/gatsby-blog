{"componentChunkName":"component---src-templates-post-template-tsx","path":"/MobX/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h1>MobX란?</h1>\n<p>Redux와 같은 <code class=\"language-text\">글로벌 상태관리 Tool</code></p>\n<h1>MobX 쓰는이유</h1>\n<p><code class=\"language-text\">객체지향(OOP)</code> 기반이므로, Redux보다 코드가 더 간결해질 수 있다.</p>\n<h1>MobX 흐름</h1>\n<p><span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 761px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/620aa6969a872bc69206e459da4370c0/fe1bc/mobx-flow.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 21.875%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA4UlEQVQY03WPwUrDQBRF8/9/IH5HXSnERcBCQVpsrLZKTJqahCZN1WRm8jJzJIMue+GsHpx7X1CWJW3b8pO/cNpEfGXP5PmBpq4J1wXXd688bCvKoqBpGnaHR+bxDZ/1G2m6J08/SKKI1WzGfrEgMMbQdR3f6ROndUifbxiGAa0U93HJ1e2W+e7IKANKKdIqZvUecjzvERlRXUebJBTLJecsI+AvMlq/SqzDOS7GWocxAzKMvljGESOCWOvvgXOTYDI4RAStFX3f+9X/9L2iqirqukZrjTaa6TOP1h5nrff8AgKpLufTOYTCAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <picture>\n          <source srcset=\"/static/620aa6969a872bc69206e459da4370c0/a59e9/mobx-flow.webp 192w,\n/static/620aa6969a872bc69206e459da4370c0/0ca9f/mobx-flow.webp 384w,\n/static/620aa6969a872bc69206e459da4370c0/751eb/mobx-flow.webp 761w\" sizes=\"(max-width: 761px) 100vw, 761px\" type=\"image/webp\">\n          <source srcset=\"/static/620aa6969a872bc69206e459da4370c0/3b721/mobx-flow.png 192w,\n/static/620aa6969a872bc69206e459da4370c0/66595/mobx-flow.png 384w,\n/static/620aa6969a872bc69206e459da4370c0/fe1bc/mobx-flow.png 761w\" sizes=\"(max-width: 761px) 100vw, 761px\" type=\"image/png\">\n          <img class=\"gatsby-resp-image-image\" src=\"/static/620aa6969a872bc69206e459da4370c0/fe1bc/mobx-flow.png\" alt=\"mobx-flow\" title=\"mobx-flow\" loading=\"lazy\" decoding=\"async\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\">\n        </picture>\n  </a>\n    </span></img>\r\naction으로 state가 바뀌었을 때, <code class=\"language-text\">단방향</code>으로 데이터가 흐르게 된다. 그 결과 여향을 받는 view들이 update된다. event가 발생하면 action으로 observable을 변경한다. observable이 변경된 것은 그 값에 의존하고 있는 computed와 side effect에게 전달된다.</p>\n<h1>MobX의 핵심 3가지</h1>\n<h2>1. state: MobX가 추적하게 되는 데이터</h2>\n<p>state가 계속 변하는 것을 MobX가 추적할 수 있도록 <code class=\"language-text\">observable</code>이라고 표기를 해줘야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> makeObservable<span class=\"token punctuation\">,</span> observable<span class=\"token punctuation\">,</span> action <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'mobx'</span>\r\n\r\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Todo</span> <span class=\"token punctuation\">{</span>\r\n  id <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\r\n  title <span class=\"token operator\">=</span> <span class=\"token string\">''</span>\r\n  finished <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\r\n\r\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>title<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token function\">makeObservable</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\r\n      title<span class=\"token operator\">:</span> observable<span class=\"token punctuation\">,</span>\r\n      finished<span class=\"token operator\">:</span> observable<span class=\"token punctuation\">,</span>\r\n      toggle<span class=\"token operator\">:</span> action<span class=\"token punctuation\">,</span>\r\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\r\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>title <span class=\"token operator\">=</span> title\r\n  <span class=\"token punctuation\">}</span>\r\n\r\n  <span class=\"token function\">toggle</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>finished <span class=\"token operator\">=</span> <span class=\"token operator\">!</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>finished\r\n  <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>2. action으로 state를 변경</h2>\n<p>action은 state를 변경하는 모든 코드를 의미한다. action을 표기해야하는 이유는 다음과 같다.</p>\n<blockquote>\n<p>MobX가 자동으로 최적화를 위하여 transactions을 적용하기 때문이다.</p>\n</blockquote>\n<p>action을 사용하면 코드를 잘 구조화하는데 도움이 되며, 의도치 않게 state를 변경하는 것을 막아준다.</p>\n<h2>derivation: 상태가 변경되었을 때 자동으로 호출</h2>\n<p>state로 부터 자동으로 도출될 수 있는 모든 것을 deriviation이라한다.\r\nderiviation은 2가지로 구분이 가능하다.</p>\n<ol>\n<li>\n<p>Computed Value</p>\n<p><code class=\"language-text\">순수함수</code>를 통해 현재 observable state로부터 도출될 수 있는 값</p>\n</li>\n<li>\n<p>Reactions<br>\nstate가 변경되었을 때, 자동으로 일어나게 되는 사이트 이펙트</p>\n</li>\n</ol>\n<ul>\n<li>derivation 에서 알아야 할 점\n<ul>\n<li>모든 derivation(computed, reaction)은 state가 변경되었을 때, <code class=\"language-text\">자동으로</code>, 그리고 <code class=\"language-text\">atomic</code>하게 업데이트된다. 즉, update중인 값을 observe할 수 없다.</li>\n<li>모든 derivation은 <code class=\"language-text\">동기적으로</code> 업데이트 되는 것이 기본이다. action이 state를 변경한 직후에, computed 값을 사용하여도,\r\ncomputed값은 action이 변경한 observable로 재계산된 값이다.</li>\n</ul>\n</li>\n</ul>\n<h2>computed를 사용하여 값 만들기</h2>\n<ul>\n<li>JS getter 함수인 get를 사용해야한다.</li>\n<li>makeObservable안에서 computed라고 표기해주어야 한다.<br>\ncomputed 값은 <code class=\"language-text\">lazily update</code>된다. 즉, 사용되지 않는 computed값은 side effect(I/O)에 필요해질 때가지는 업데이트 되지 않는다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> makeObservable<span class=\"token punctuation\">,</span> observable<span class=\"token punctuation\">,</span> computed <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"mobx\"</span>\r\n\r\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">TodoList</span> <span class=\"token punctuation\">{</span>\r\n    todos <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\r\n    <span class=\"token keyword\">get</span> <span class=\"token function\">unfinishedTodoCount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>todos<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>todo <span class=\"token operator\">=></span> <span class=\"token operator\">!</span>todo<span class=\"token punctuation\">.</span>finished<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>length\r\n    <span class=\"token punctuation\">}</span>\r\n    <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>todos<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token function\">makeObservable</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\r\n            todos<span class=\"token operator\">:</span> observable<span class=\"token punctuation\">,</span>\r\n            unfinishedTodoCount<span class=\"token operator\">:</span> computed\r\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\r\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>todos <span class=\"token operator\">=</span> todos\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>get이 있는 unfinishedTodoCount 함수는 computed 값을 만들어낸다. 이 함수는 observable이 변경되면 자동으로 update된다.</p>\n<h2>reactions로 사이트 이펙트 만들기</h2>\n<p>reaction 또한 observable이 변경되면 자동으로 실행된다. reaction은 computed와는 다르게, 어떤 결과를 반환하는게 아니라 <code class=\"language-text\">side affect를 만들어내기</code>만 한다. (console.log 찍기, 네트워크 요청 등등…)</p>\n<h2>reactive한 리액트 컴포넌트</h2>\n<p>observer로 리액트 컴포넌트를 감싸면, 컴포넌트를 reactive하게 만들 수 있다.</p>\n<blockquote>\n<p>observer converts React components into dreivations of the data they render</p>\n</blockquote>\n<p>observer를 사용하면, 컴포넌트는 mobx가 랜더링 해야하는 derivation으로 만들어버린다. 즉, 불필요한 리렌더링을 막을 수 있다.</p>\n<blockquote>\n<p>MobX will simply make sure the components are always re-rendered whenever needed, and never more than that.</p>\n</blockquote>\n<p>MobX가 스스로 component가 사용하는 observable이 변경될 때만 컴포넌트를 리렌더링한다. 이는 해당 component의 부모가 리렌더링 될때, 자식 componnent는 리렌더링하지 않아도 되는 경우, 리렌더링을 막아준다.</p>\n<h2>커스텀 reactions 만들기</h2>\n<p>autorun이나 reaction, when 함수를 사용하여 reaction을 만들 수 있다.<br>\nreaction이 그 안에서 주시하고 있는 observable이나 computed의 값이 변할 때, reaction인 함수가 자동으로 실행된다.<br>\n아래 코드는 todos.unfinishedTodoCount값이 바뀔 때마다 실행된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// A function that automatically observes the state.</span>\r\n<span class=\"token function\">autorun</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\r\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Tasks left: '</span> <span class=\"token operator\">+</span> todos<span class=\"token punctuation\">.</span>unfinishedTodoCount<span class=\"token punctuation\">)</span>\r\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>이게 가능한 이유는 다음과 같다.</p>\n<blockquote>\n<p>MobX reacts to any existing observable property that is read during the execution of a tracked function.<br>\n즉, MobX가 추적하고 있는 함수가 실행되는 동안, 사용되는 observable property에 반응을 하기 때문이다.</p>\n</blockquote>\n<p><a href=\"https://velog.io/@yejineee/MobX-%EC%BD%94%EC%96%B4-%EA%B0%9C%EB%85%90\" target=\"_blank\" rel=\"nofollow\">참고링크</a></p>","frontmatter":{"title":"MobX 개념정리","summary":"MobX 개념을 공부하기 위해 MobX에 대한 블로그 글을 정리해보았다.","date":"2022.08.11.","categories":["MobX"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABq0lEQVQoz5WTz0sbURDH809YqAdPpV4VD4L4F1joyavYgKAgSgNBEH9cAkLRQ6xJLT1FY0Rj3UjUaNWCJFUTszFGj4WWGMGgjZXEze4K8pHsdk1CpOrhyzzezPu8mTfzTEp0EXn/K4aVIwvI+6XSfaVx/5OpLDjmQ40voxz4UeN+fS0K/y7yPglqug8SBaSgi2xgnNyGk9w3B9mAnfzODEpUIP/9c7GKB2T4dGDEi3q0RvpDKz/bqvnd/oJf76pIdbwk5+pBOVxB2nQgRxdRRT2TG1HQFfNp1oAWgcfrnNlaSFqbOLHUkx5o4u9wM1eTZpREAGnTqR3I7s5xHfaSCXq4DM1yvu3WrFqR4fE66ZG3JHvryMwMcT1t4aKvnstPZlQN6NCy2XOP4v84yJJ9gIN5O1tfbEQ8Y9zGl8hXAG1vOLU2cmpp4Ly/kTNrHRcTbaiJtcqSY4KWVaHc0mYVgYlV/kyYSXW+ItlVS6r7NSedNWRc71ELb7jlfEZTjI3wHFJoGumHGynkRgpOIYf1cSkFPgQuA5bNl+grl3F41/PMOXyknMIsPuWn3AG3RdWGHcLxngAAAABJRU5ErkJggg=="},"images":{"fallback":{"src":"/static/8d3a2e4735647ce02632d7c2e18a00ae/4b4a3/thumbnail-mobx.png","srcSet":"/static/8d3a2e4735647ce02632d7c2e18a00ae/3e7b4/thumbnail-mobx.png 477w,\n/static/8d3a2e4735647ce02632d7c2e18a00ae/c0022/thumbnail-mobx.png 954w,\n/static/8d3a2e4735647ce02632d7c2e18a00ae/4b4a3/thumbnail-mobx.png 1908w","sizes":"(min-width: 1908px) 1908px, 100vw"},"sources":[{"srcSet":"/static/8d3a2e4735647ce02632d7c2e18a00ae/f3bdd/thumbnail-mobx.webp 477w,\n/static/8d3a2e4735647ce02632d7c2e18a00ae/2ef02/thumbnail-mobx.webp 954w,\n/static/8d3a2e4735647ce02632d7c2e18a00ae/c0ebe/thumbnail-mobx.webp 1908w","type":"image/webp","sizes":"(min-width: 1908px) 1908px, 100vw"}]},"width":1908,"height":1070}},"publicURL":"/static/8d3a2e4735647ce02632d7c2e18a00ae/thumbnail-mobx.png"}}}}]}},"pageContext":{"slug":"/MobX/"}},"staticQueryHashes":[]}